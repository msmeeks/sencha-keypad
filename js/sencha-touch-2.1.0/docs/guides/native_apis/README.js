Ext.data.JsonP.native_apis({"title":"Using Native APIs","guide":"<h1>Accessing Native APIs with Ext.device</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/native_apis-section-1'>Getting Started</a></li>\n<li><a href='#!/guide/native_apis-section-2'>Connection</a></li>\n<li><a href='#!/guide/native_apis-section-3'>Notification</a></li>\n<li><a href='#!/guide/native_apis-section-4'>Camera</a></li>\n<li><a href='#!/guide/native_apis-section-5'>Orientation</a></li>\n<li><a href='#!/guide/native_apis-section-6'>Custom Scheme URLs</a></li>\n<li><a href='#!/guide/native_apis-section-7'>Packaging</a></li>\n</ol>\n</div>\n\n<p>One of the biggest benefits of native packaging is access to native APIs. Sencha Touch 2 provides a access to native APIs through its <code>Ext.device</code> API. The <code>Ext.device</code> API does not itself provide the native API capabilities - it's just a wrapper that can be used to access native APIs powered by the Sencha Packager or third party solutions like PhoneGap and the iOS Simulator. At the time of writing, <code>Ext.device</code> provides 4 APIs:</p>\n\n<ul>\n<li><a href=\"#!/api/Ext.device.Connection\" rel=\"Ext.device.Connection\" class=\"docClass\">Ext.device.Connection</a> - tells you whether or not the device has a current connection to the internet.</li>\n<li><a href=\"#!/api/Ext.device.Notification\" rel=\"Ext.device.Notification\" class=\"docClass\">Ext.device.Notification</a> - allows you to use native notification windows (the native version of <a href=\"#!/api/Ext.Msg\" rel=\"Ext.Msg\" class=\"docClass\">Ext.Msg</a>).</li>\n<li><a href=\"#!/api/Ext.device.Orientation\" rel=\"Ext.device.Orientation\" class=\"docClass\">Ext.device.Orientation</a> - gives you as much information as the device provides about its current orientation.</li>\n<li><a href=\"#!/api/Ext.device.Camera\" rel=\"Ext.device.Camera\" class=\"docClass\">Ext.device.Camera</a> - allows your app to take pictures or select from the camera library (with the user's permission).</li>\n</ul>\n\n\n<h2 id='native_apis-section-1'>Getting Started</h2>\n\n<p>Because we want to keep our apps small, and because native APIs only apply in native packaged apps, the <code>Ext.device</code> API is not included in the standard build of Sencha Touch 2. When you want to use any of the Device API's , you must require them using <code><a href=\"#!/api/Ext-method-require\" rel=\"Ext-method-require\" class=\"docClass\">Ext.require</a></code>:</p>\n\n<pre><code><a href=\"#!/api/Ext-method-require\" rel=\"Ext-method-require\" class=\"docClass\">Ext.require</a>('<a href=\"#!/api/Ext.device.Connection\" rel=\"Ext.device.Connection\" class=\"docClass\">Ext.device.Connection</a>');\n\n<a href=\"#!/api/Ext-method-application\" rel=\"Ext-method-application\" class=\"docClass\">Ext.application</a>({\n    name: 'MyApp'\n    // the rest of your app follows\n});\n</code></pre>\n\n<h2 id='native_apis-section-2'>Connection</h2>\n\n<p>The Connection API is used to determine whether or not the device is currently online. It exposes two main methods - <code>isOnline</code> and <code>getType</code>:</p>\n\n<pre><code>if (<a href=\"#!/api/Ext.device.Connection-method-isOnline\" rel=\"Ext.device.Connection-method-isOnline\" class=\"docClass\">Ext.device.Connection.isOnline</a>()) {\n    <a href=\"#!/api/Ext.Msg-method-alert\" rel=\"Ext.Msg-method-alert\" class=\"docClass\">Ext.Msg.alert</a>('You are currently connected via ' + <a href=\"#!/api/Ext.device.Connection-method-getType\" rel=\"Ext.device.Connection-method-getType\" class=\"docClass\">Ext.device.Connection.getType</a>());\n} else {\n    <a href=\"#!/api/Ext.Msg-method-alert\" rel=\"Ext.Msg-method-alert\" class=\"docClass\">Ext.Msg.alert</a>('You are not currently connected');\n}\n</code></pre>\n\n<p>This is probably the simplest of the APIs offered by <code>Ext.device</code>. If you load this up on a device or inside the simulator you'll see a Sencha Touch message box appearing either telling you you're offline, or if you're online, which connection type you have (wifi, 2g, 3g etc). See the <a href=\"#!/api/Ext.device.Connection\" rel=\"Ext.device.Connection\" class=\"docClass\">Ext.device.Connection</a> docs for a full list of possible connection types.</p>\n\n<h2 id='native_apis-section-3'>Notification</h2>\n\n<p>Notifications are used to show native dialog boxes. Notifications work very much like <a href=\"#!/api/Ext.Msg\" rel=\"Ext.Msg\" class=\"docClass\">Ext.Msg</a> and can be configured in many different ways. For example, here's how we can display a native notification box with a title and a message:</p>\n\n<pre><code><a href=\"#!/api/Ext.device.Notification-method-show\" rel=\"Ext.device.Notification-method-show\" class=\"docClass\">Ext.device.Notification.show</a>({\n    title: 'One Button',\n    message: 'This is a simple notification with one button.'\n});\n</code></pre>\n\n<p>This causes a native notification window to appear like this:</p>\n\n<p><p class='screenshot'><img src='guides/native_apis/notifications-simple.png' alt=''><span></span></p></p>\n\n<p>This is just going to pop up a native message box with our configured title and message. It adds an OK button too so the user can dismiss the message. When the user taps on the button, our callback is called - in this case we'll respond to their button tap by opening a second notification:</p>\n\n<pre><code><a href=\"#!/api/Ext.device.Notification-method-show\" rel=\"Ext.device.Notification-method-show\" class=\"docClass\">Ext.device.Notification.show</a>({\n    title: 'One Button',\n    message: 'This is a simple notification with one button.',\n\n    callback: function(button) {\n        //When the user taps a button, show another notification\n        <a href=\"#!/api/Ext.device.Notification-method-show\" rel=\"Ext.device.Notification-method-show\" class=\"docClass\">Ext.device.Notification.show</a>({\n            message: 'You pressed: \"' + button + '\"'\n        });\n    }\n});\n</code></pre>\n\n<p>We didn't provide a title for the second message, which is fine - it just shows the message and an OK button. We can customize the buttons that are presented to the user easily:</p>\n\n<pre><code><a href=\"#!/api/Ext.device.Notification-method-show\" rel=\"Ext.device.Notification-method-show\" class=\"docClass\">Ext.device.Notification.show</a>({\n    title: 'Multiple Buttons',\n    message: 'This is a notification with multiple buttons.',\n    buttons: [\"Cancel\", \"Login\", \"Another\"],\n\n    callback: function(button) {\n        //When the user taps a button, show another notification\n        <a href=\"#!/api/Ext.device.Notification-method-show\" rel=\"Ext.device.Notification-method-show\" class=\"docClass\">Ext.device.Notification.show</a>({\n            message: 'You pressed: \"' + button + '\"'\n        });\n    }\n});\n</code></pre>\n\n<p>This time we provided three button text strings in the <em>buttons</em> array - when we run this code now we see the buttons stacked on top of one another:</p>\n\n<p><p class='screenshot'><img src='guides/native_apis/notifications-custom.png' alt=''><span></span></p></p>\n\n<h3>Vibration</h3>\n\n<p>The final capability of the notification API is to vibrate the device. Making this happen is straightforward:</p>\n\n<pre><code>Ext.device.notification.vibrate();\n</code></pre>\n\n<p>This will cause the device to vibrate for a short time, and can be called as often as desired.</p>\n\n<h2 id='native_apis-section-4'>Camera</h2>\n\n<p>The Camera API allows you to take pictures using the phone's camera, or alternatively select an image from the existing photo library available on the phone. Here's how we can ask the device to prompt the user to take a new picture:</p>\n\n<pre><code><a href=\"#!/api/Ext.device.Camera-method-capture\" rel=\"Ext.device.Camera-method-capture\" class=\"docClass\">Ext.device.Camera.capture</a>({\n    source: 'camera',\n    destination: 'file',\n\n    success: function(url) {\n        //show the newly captured image in a full screen <a href=\"#!/api/Ext.Img\" rel=\"Ext.Img\" class=\"docClass\">Ext.Img</a> component:\n        <a href=\"#!/api/Ext-method-create\" rel=\"Ext-method-create\" class=\"docClass\">Ext.create</a>('<a href=\"#!/api/Ext.Img\" rel=\"Ext.Img\" class=\"docClass\">Ext.Img</a>', {\n            src: url,\n            fullscreen: true\n        });\n    }\n});\n</code></pre>\n\n<p>Note that we specified two options here (apart from our <em>success</em> callback) - source and destination. We can set <em>source</em> to either 'camera' or 'library' - the first option opens the camera to take a new picture, the second opens a native photo browser window to select an existing image. Our example above is going to open the camera app then save the new image to a file, finally calling our <em>success</em> function with the local url to that file.</p>\n\n<p>There are several other options that can be passed into the <a href=\"#!/api/Ext.device.Camera-method-capture\" rel=\"Ext.device.Camera-method-capture\" class=\"docClass\">Ext.device.Camera.capture</a> call:</p>\n\n<ul>\n<li><code>success</code> - the function to call if an image was successfully acquired.</li>\n<li><code>failure</code> - the function to call if an image could not be acquired.</li>\n<li><code>scope</code> - the scope to run the two functions above in (sets the value of <code>this</code>).</li>\n<li><code>quality</code> - gives the camera a hint about the compression quality we'd like our image to have (0-100).</li>\n<li><code>width</code> - the desired width of the new image, in px.</li>\n<li><code>height</code> - the desired height of the new image, in px.</li>\n<li><code>source</code> - can be 'camera' or 'library' - 'camera' takes a new picture, 'library' chooses an existing one.</li>\n<li><code>destination</code> - can be 'file' or 'data' - file returns a local url to the new image, 'data' returns a Base64 encoded string of the image.</li>\n<li><code>encoding</code> - can be 'jpeg', 'jpg' or 'png' - the first two options encode the image as a JPEG, the third as a PNG.</li>\n</ul>\n\n\n<p>Any number of these options can be passed into your <a href=\"#!/api/Ext.device.Camera-method-capture\" rel=\"Ext.device.Camera-method-capture\" class=\"docClass\">Ext.device.Camera.capture</a> call.</p>\n\n<h2 id='native_apis-section-5'>Orientation</h2>\n\n<p>The orientation API yields information about the current orientation of the device. This time we register a handler function that is called every time a change in orientation is detected:</p>\n\n<pre><code><a href=\"#!/api/Ext.device.Orientation-method-on\" rel=\"Ext.device.Orientation-method-on\" class=\"docClass\">Ext.device.Orientation.on</a>('orientation', function(e) {\n    var alpha = Math.round(e.alpha),\n        beta = Math.round(e.beta),\n        gamma = Math.round(e.gamma);\n\n    console.log(alpha, beta, gamma);\n});\n</code></pre>\n\n<p>This is going to provide a stream of console messages with the alpha, beta and gamma orientation of the device. These values correspond to the three dimensions the device can be pivoted around, are are expressed in degrees ranging from 0 to 360.</p>\n\n<h2 id='native_apis-section-6'>Custom Scheme URLs</h2>\n\n<p>Using custom scheme URLs to application your application from other applications:</p>\n\n<pre><code><a href=\"#!/api/Ext-method-application\" rel=\"Ext-method-application\" class=\"docClass\">Ext.application</a>({\n    name: 'Sencha',\n    requires: ['<a href=\"#!/api/Ext.device.Device\" rel=\"Ext.device.Device\" class=\"docClass\">Ext.device.Device</a>'],\n    launch: function() {\n        if (<a href=\"#!/api/Ext.device.Device-property-scheme\" rel=\"Ext.device.Device-property-scheme\" class=\"docClass\">Ext.device.Device.scheme</a>) {\n            // the application was opened via another application. Do something:\n            alert('Applicaton pened via another application: ' + Ext.device.Device.scheme.url);\n        }\n\n        // Listen for future changes\n        <a href=\"#!/api/Ext.device.Device-method-on\" rel=\"Ext.device.Device-method-on\" class=\"docClass\">Ext.device.Device.on</a>('schemeupdate', function(device, scheme) {\n            // the application was launched, closed, and then launched another from another application\n            // this means onReady wont be called again ('cause the application is already running in the \n            // background) - but this event will be fired\n            alert('Applicated reopened via another application: ' + scheme.url);\n        }, this);\n    }\n});\n</code></pre>\n\n<p>Of course, you must add add the custom URLs you would like to use when packaging your application. You can do this by adding the following code into the <code>rawConfig</code> property inside your <code>package.json</code> file (Sencha Native Packager configuration file):</p>\n\n<pre><code>{\n    ...\n    \"rawConfig\": \"&lt;key&gt;CFBundleURLTypes&lt;/key&gt;&lt;array&gt;&lt;dict&gt;&lt;key&gt;CFBundleURLSchemes&lt;/key&gt;&lt;array&gt;&lt;string&gt;sencha&lt;/string&gt;&lt;/array&gt;&lt;key&gt;CFBundleURLName&lt;/key&gt;&lt;string&gt;com.sencha.example&lt;/string&gt;&lt;/dict&gt;&lt;/array&gt;\"\n    ...\n}\n</code></pre>\n\n<p>You can change the available URL schemes and the application identifier above.</p>\n\n<p>You can then test it by packaging and installing the application onto a device/iOS Simulator, opening Safari and typing: <code>sencha:testing</code>. The application will launch and it will <code>alert</code> the URL you specified.</p>\n\n<p><strong>Note:</strong> This currently only works with the Sencha Native Packager. If you attempt to listen to this event when packaged with PhoneGap or simply in the browser, it will not function.</p>\n\n<h2 id='native_apis-section-7'>Packaging</h2>\n\n<p>Now that you have a grasp of how to use the <code>Ext.device</code> API to access native device functionality, proceed to the guides to packaging your app for <a href=\"#!/guide/native_packaging\">iOS</a> and <a href=\"#!/guide/native_android\">Android</a> to start testing on a real device.</p>\n"});